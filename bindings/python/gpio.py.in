import atexit
import contextlib
import ctypes

from _libsoc import (
    DIRECTION_INPUT, DIRECTION_OUTPUT,
    EDGE_BOTH, EDGE_FALLING, EDGE_NONE, EDGE_RISING,
    LS_SHARED, LS_GREEDY, LS_WEAK,
    start_gpio_cb,
)


class GPIO(object):
    _lib = ctypes.CDLL('@prefix@/lib/libsoc.so')
    _board_config = None

    def __init__(self, id, direction, edge=EDGE_NONE, mode=LS_SHARED,
                 callback=None):
        self.id = id
        if not isinstance(id, int):
            raise TypeError('Invalid gpio id must be an "int"')
        if mode not in (LS_SHARED, LS_GREEDY, LS_WEAK):
            raise ValueError('Invalid GPIO mode: %d' % mode)
        if direction not in (DIRECTION_INPUT, DIRECTION_OUTPUT):
            raise ValueError('Invalid GPIO direction: %d' % direction)
        edges = (EDGE_RISING, EDGE_FALLING, EDGE_NONE, EDGE_BOTH)
        if direction == DIRECTION_INPUT and edge not in edges:
            raise ValueError('Invalid GPIO edge: %d' % edge)

        self.mode = mode
        self.direction = direction
        self.edge = edge
        self.callback = callback
        self._gpio = None

    def open(self):
        assert self._gpio is None
        self._gpio = GPIO._lib.libsoc_gpio_request(self.id, self.mode)
        if self._gpio == 0:  # NULL from native code
            raise IOError('Unable to open GPIO_%d' % self.id)
        GPIO._lib.libsoc_gpio_set_direction(self._gpio, self.direction)
        if self.direction == DIRECTION_INPUT:
            if GPIO._lib.libsoc_gpio_set_edge(self._gpio, self.edge) != 0:
                raise IOError('Error setting edge for GPIO_%d' % self.id)
            if self.callback:
                start_gpio_cb(self._gpio, self.callback)

    def close(self):
        if self._gpio:
            if self.direction == DIRECTION_INPUT and self.callback:
                GPIO._lib.libsoc_gpio_callback_interrupt_cancel(self._gpio)
            GPIO._lib.libsoc_gpio_free(self._gpio)
            self._gpio = None

    def get_direction(self):
        d = GPIO._lib.libsoc_gpio_get_direction(self._gpio)
        if d == -1:
            raise IOError('Error reading GPIO_%d direction: %d' % self.id)
        return d

    @staticmethod
    def gpio_id(pin):
        if not GPIO._board_config:
            GPIO._board_config = GPIO._lib.libsoc_board_init()
            atexit.register(GPIO._lib.libsoc_board_free, GPIO._board_config)
        gpio = GPIO._lib.libsoc_board_gpio_id(GPIO._board_config, pin)
        if gpio == -1:
            raise ValueError('Invalid GPIO pin name(%s)' % pin)
        return gpio

    @staticmethod
    def set_debug(enabled):
        v = 0
        if enabled:
            v = 1
        GPIO._lib.libsoc_set_debug(v)

    def set_high(self):
        assert self.direction == DIRECTION_OUTPUT
        GPIO._lib.libsoc_gpio_set_level(self._gpio, 1)

    def set_low(self):
        assert self.direction == DIRECTION_OUTPUT
        GPIO._lib.libsoc_gpio_set_level(self._gpio, 0)

    def is_high(self):
        l = GPIO._lib.libsoc_gpio_get_level(self._gpio)
        if l == -1:
            raise IOError('Error reading GPIO_%d level' % self.id)
        return l == 1

    def wait_for_interrupt(self, timeout):
        assert self.direction == DIRECTION_INPUT
        if self._lib.libsoc_gpio_wait_interrupt(self._gpio, timeout) != 0:
            raise IOError('Error waiting for interrupt on GPIO_%d' % self.id)

    def get_edge(self):
        assert self.direction == DIRECTION_INPUT
        e = GPIO._lib.libsoc_gpio_get_edge(self._gpio)
        if e == -1:
            raise IOError('Error reading GPIO_%d edge' % self.id)
        return e


@contextlib.contextmanager
def activate_gpios(gpios):
    try:
        for g in gpios:
            g.open()
        yield
    finally:
        for g in reversed(gpios):
            g.close()
